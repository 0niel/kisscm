# Системы контроля версий

**Системы контроля версий** – это класс программных систем, отвечающих за управление изменениями в компьютерных программах, документах, веб-сайтах и других наборах данных. Система контроля версий отслеживает изменения в файл или набор файлов в течение времени и позволяет вернуться позже к определённой версии файлов.

**Коммит** – фиксация факта изменений в системе контроля версий (СКВ).

В системе контроля версий обычно выделяются следующие функции:

* Хранение данных.
* Отслеживание изменений в данных (история, включая метаданные слияния).
* Распространение данных и истории изменений среди соавторов проекта.

Два наиболее распространенных варианта учета изменений данных в СКВ:

* набор изменений на основе различий (дельты),
* представление данных в виде направленного ациклического графа.

Системы CVS, Subversion, Perforce, Bazaar и т.д. представляют хранимую информацию в виде набора файлов и изменений, сделанных в каждом файле, по времени (обычно это называют контролем версий, основанным на различиях), см. @fig:vcs1.

![Хранение данных как набора изменений относительно первоначальной версии каждого из файлов](vcs1.png){#fig:vcs1}

Другой подход к хранению данных больше похож на набор снимков миниатюрной файловой системы. Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта, СКВ запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, СКВ не запоминает эти файлы вновь, а только создает ссылку на предыдущую версию идентичного файла, который уже сохранен. СКВ представляет свои данные как граф снимков, см. @fig:vcs2.

С точки зрения типа используемой истории изменений системы контроля версий различаются:

* использованием линейной истории,
* использованием графового представления для истории изменений.

![Хранение данных как снимков проекта во времени](vcs2.png){#fig:vcs2}

Системы контроля версий бывают различаются с точки зрения хранения и доставки своего содержимого:

* Локальные системы.
* Централизованные системы.
* Распределенные системы.

**Локальные системы контроля версий**. Многие люди в качестве метода контроля версий применяют копирование файлов в отдельную директорию (возможно даже, директорию с отметкой по времени). Данный подход очень распространён из-за его простоты, однако он невероятно сильно подвержен появлению ошибок. Можно легко забыть, в какой директории вы находитесь, и случайно изменить не тот файл или скопировать не те файлы, которые вы хотели.
Для того, чтобы решить эту проблему, были разработаны локальные СКВ с простой базой данных, которая хранит записи о всех изменениях в файлах, осуществляя тем самым контроль ревизий, см. @fig:vcs3.

Одной из популярных СКВ была система RCS, которая и сегодня распространяется со многими компьютерами. RCS хранит на диске наборы патчей (различий между файлами) в специальном формате, применяя которые она может воссоздавать состояние каждого файла в заданный момент времени.

Локальные СКВ страдают от следующей проблемы: когда вся история проекта хранится в одном месте, есть риск потерять все.

![Локальный контроль версий](vcs3.png){#fig:vcs3}

**Централизованные системы контроля версий**. Следующая серьезная проблема, с которой сталкиваются разработчики, – это необходимость взаимодействовать с другими разработчиками. Для того, чтобы разобраться с ней, были разработаны централизованные системы контроля версий (ЦСКВ). Такие системы, как CVS, Subversion и Perforce, используют единый сервер, содержащий все версии файлов, и некоторое количество клиентов получают файлы из этого централизованного хранилища, см. @fig:vcs4. Применение ЦСКВ являлось стандартом на протяжении многих лет.

![Централизованный контроль версий](vcs4.png){#fig:vcs4}
 
Такой подход имеет множество преимуществ, особенно перед локальными СКВ. Например, все разработчики проекта в определенной степени знают, чем занимается каждый из них. Администраторы имеют полный контроль над тем, кто и что может делать, и гораздо проще администрировать ЦСКВ, чем оперировать локальными базами данных на каждом клиенте.

Несмотря на это, данный подход тоже имеет серьезные минусы. Самый очевидный минус – это единая точка отказа, представленная централизованным сервером. Если этот сервер выйдет из строя на час, то в течение этого времени никто не сможет использовать контроль версий для сохранения изменений, над которыми работает, а также никто не сможет обмениваться этими изменениями с другими разработчиками. Если жёсткий диск, на котором хранится центральная БД, повреждён, а своевременные точки сохранения отсутствуют, о будет потеряно все – вся история проекта, не считая единичных снимков репозитория, которые сохранились на локальных машинах разработчиков.

**Распределённые системы контроля версий**. В РСКВ (таких как Git, Mercurial, Bazaar или Darcs) клиенты не просто скачивают снимок всех файлов (состояние файлов на определенный момент времени) – они полностью копируют репозиторий. В этом случае, если один из серверов, через который разработчики обменивались данными, будет недоступен, любой клиентский репозиторий может быть скопирован на другой сервер для продолжения работы. Каждая копия репозитория является полным вариантом всех данных, см. @fig:vcs5.

Многие РСКВ могут одновременно взаимодействовать с несколькими удаленными репозиториями, благодаря этому можно работать с различными группами людей, применяя различные подходы единовременно в рамках одного проекта. Это позволяет применять сразу несколько подходов в разработке, например, иерархические модели, что совершенно невозможно в централизованных системах.

![Распределенный контроль версий](vcs5.png){#fig:vcs5}

Системы контроля версий также различаются по способу разрешения конфликтов при изменений одного и того же файла со стороны нескольких разработчиков:

* механизм блокировки,
* сценарий слияния изменений перед коммитом,
* сценарий слияния изменений после коммита.

При **блокировке** рабочие файлы обычно доступны только для чтения, поэтому их нельзя просто так изменить. Необходимо дать запрос СКВ сделать рабочий файл доступным для записи, заблокировав его; только один пользователь может делать это в любой момент времени. Когда изменения будут зарегистрированы, то данные разблокируются, и рабочий файл снова становится доступным только для чтения. Это позволяет другим пользователям заблокировать файл для внесения дальнейших изменений.

В **сценарии слияния перед коммитом** СКВ отслеживает, когда осуществляется попытка выполнить коммит файла или файлов, которые уже изменились с момента начала редактирования, и в результате система требует разрешения конфликта, прежде чем коммит может быть завершен.

Существуют СКВ, которые никогда не блокируют коммиты – это **сценарий слияния после коммита**. Если копия репозитория изменилась с момента извлечения файлов, коммит можно просто перенаправить в новую ветку. Впоследствии ветви могут оставаться отдельными; или любой разработчик может выполнить слияние, которое снова объединит их.

Модель «фиксация перед слиянием» приводит к очень гибкому стилю разработки, в котором разработчики создают и повторно объединяют множество небольших веток. Это упрощает экспериментирование и записывает все, что пробуют разработчики, таким образом, чтобы это было полезно для проверки кода.

В наиболее общем случае репозиторий под управлением СКВ, работающей по сценарию слияния после коммита, может иметь форму произвольно сложного ориентированного ациклического графа. Такие СКВ часто выполняют слияние с учетом истории, используя алгоритмы, которые пытаются учитывать не только содержимое сливаемых версий, но и содержимое их общих предков в графе репозитория.

## История развития систем контроля версий

На @fig:vcs6 показана временная шкала эволюции систем контроля версий.

![Эволюция систем контроля версий](vcs6.png){#fig:vcs6}

В @tbl:table1 представлены три поколения СКВ.

: Поколения систем контроля версий {#tbl:table1}

| Поколение | Модель взаимодействия | Единица операции | Разрешение конфликтов | Примеры |
| --- | --- | --- | --- | --- |
| Первое | Локальный доступ | Файл | Блокировка | RCS, SCCS |
| Второе | Централизованное | Файл/Множество файлов | Слияние до коммита |CVS, SourceSafe, Subversion, Team Foundation Server |
| Третье | Распределенное | Множество файлов | Слияние после коммита | Bazaar, Git, Mercurial, Fossil |

## Система Git

Git напоминает миниатюрную файловую систему с утилитами, надстроенными над ней, нежели просто на СКВ.

Для работы большинства операций в Git достаточно локальных файлов и ресурсов – в основном, системе не нужна никакая информация с других компьютеров в вашей сети. Так как вся история проекта хранится прямо на локальном диске, большинство операций кажутся чуть ли не мгновенными.

В Git для всего вычисляется хеш-сумма, и только потом происходит сохранение. В дальнейшем обращение к сохраненным объектам происходит по этой хеш-сумме. Это значит, что невозможно изменить содержимое файла или директории так, чтобы Git не узнал об этом. Данная функциональность встроена в Git на низком уровне и является неотъемлемой частью его философии. Вы не потеряете информацию во время её передачи и не получите повреждённый файл без ведома Git.

Механизм, которым пользуется Git при вычислении хеш-сумм, называется SHA-1 хеш. Это строка длинной в 40 шестнадцатеричных символов (0-9 и a-f), она вычисляется на основе содержимого файла или структуры каталога. SHA-1 хеш выглядит примерно так:

```default
24b9da6552252987aa493b52f8696cd6d3b00373
``` 

Вы будете постоянно встречать хеши в Git, потому что он использует их повсеместно. На самом деле, Git сохраняет все объекты в свою базу данных не по имени, а по хеш-сумме содержимого объекта.

Когда вы производите какие-либо действия в Git, практически все из них только добавляют новые данные в базу Git. Очень сложно заставить систему удалить данные либо сделать что-то, что нельзя впоследствии отменить. Как и в любой другой СКВ, вы можете потерять или испортить свои изменения, пока они не зафиксированы, но после того, как вы зафиксируете снимок в Git, будет очень сложно что-либо потерять, особенно, если вы регулярно синхронизируете свою базу с другим репозиторием.

У Git есть три основных состояния, в которых могут находиться ваши файлы: зафиксированное (committed), изменённое (modified) и подготовленное (staged).

* Зафиксированный значит, что файл уже сохранён в вашей локальной базе.
* К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
* Подготовленные файлы – это изменённые файлы, отмеченные для включения в следующий коммит.

Существует три основных элемента проекта Git:

* Git-директория (Git directory),
* рабочая директория (working directory),
* область подготовленных файлов (staging area).

**Git-директория** – это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git, и это та часть, которая копируется при клонировании репозитория с другого компьютера.

**Рабочая директория** является снимком версии проекта. Файлы распаковываются из сжатой базы данных в Git-директории и располагаются на диске, для того чтобы их можно было изменять и использовать.

**Область подготовленных файлов** – это файл, обычно располагающийся в вашей Git-директории, в нём содержится информация о том, какие изменения попадут в следующий коммит. Эту область ещё называют «индекс», однако называть её stage-область также общепринято.

Базовый подход в работе с Git выглядит так:

* Вы изменяете файлы в вашей рабочей директории.
* Вы выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, добавляя тем самым снимки только этих изменений в область подготовленных файлов.
* Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в вашу Git-директорию.
  
Если определенная версия файла есть в Git-директории, эта версия считается зафиксированной. Если версия файла изменена и добавлена в индекс, значит, она подготовлена. И если файл был изменен с момента последнего распаковывания из репозитория, но не был добавлен в индекс, он считается измененным.

## Модель данных Git

**Снимки**. Git моделирует историю файлов и каталогов в некотором каталоге верхнего уровня как серию снимков. В терминологии Git файл называется «blob» (Binary Large Object), это просто набор байтов. Каталог называется «деревом», и он сопоставляет имена с blobs или деревьями (то есть каталоги могут содержать в себе другие каталоги). 

Снимок - это отслеживаемое СКВ дерево.

Пример дерева:

```default
<root> (tree)
|
+- foo (tree)
|  |
|  + bar.txt (blob, contents = "hello world")
|
+- baz.txt (blob, contents = "git is wonderful")
```

Модель истории. В Git **история** - это ориентированный ациклический граф снимков. В псевдокоде:

```default
// файл – последовательность байт
type blob = array<byte>
 
// директория содержит именованные файлы или директории
type tree = map<string, tree | blob>
 
// коммит содержит родителей, метаданные и дерево 
type commit = struct {
    parent: array<commit>
    author: string
    message: string
    snapshot: tree
}
```

**Объекты**. Объект это blob, дерево или коммит. Объекты адресуются по своим хеш-значениям SHA-1.

```default
type object = blob | tree | commit
 
objects = map<string, object>
 
def store(object):
    id = sha1(object)
    objects[id] = object
 
def load(id):
    return objects[id]
```

**Ссылки**. Ссылки указывают на объекты.

```default
references = map<string, string>
 
def update_reference(name, id):
    references[name] = id
 
def read_reference(name):
    return references[name]
 
def load_reference(name_or_id):
    if name_or_id in references:
        return load(references[name_or_id])
    else:
        return load(name_or_id)
```

Управление git удобнее всего осуществлять из командной строки. Ниже представлены некоторые команды git:
 
Базовые команды

```default
git help <command>: помощь по git
git init: инициализация нового репозитория
git status: текущий статус репозитория
git add <filename>: добавить файл в подготовительную область
git commit: создать новый коммит
git log: показать историю изменений
git log --all --graph --decorate: история, как граф
git diff <filename>: изменения по сравнению с состоянием в подготовительной области
git diff <revision> <filename>: изменения в разных снимках для файла
git checkout <revision>: обновление HEAD и текущей ветки
```

Ветки и слияние

```default
git branch: показать ветки
git branch <name>: создать ветку
git checkout -b <name>: создать ветку и переключиться на нее
то же, что и git branch <name>; git checkout <name>
git merge <revision>: слияние в текущую ветку
```

Удаленная работа

```default
git remote: список удаленных репозиториев
git remote add <name> <url>: добавить удаленный репозиторий
git push <remote> <local branch>:<remote branch>: отправить данные для изменения в удаленном репозитории
git branch --set-upstream-to=<remote>/<remote branch>: установить взаимосвязь между локальной и удаленной ветками
git fetch: получить данные из удаленного репозитория
git pull: то же, что и git fetch; git merge
git clone: загрузить удаленный репозиторий
```

Отмена действий

```default
git commit --amend: отредактировать содержимое коммита
git reset HEAD <file>: отменить добавление файла
```
