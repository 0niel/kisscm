# Системы автоматизации сборки

**Автоматизация сборки** — автоматизация создания программного обеспечения и связанные с этим процессы, включая компиляцию исходного кода, упаковку кода в дистрибутив и выполнение автоматических тестов.

**Системы сборки** автоматизируют выполнение повторяемых задач как на уровне отдельных пользователей, так и для крупных организаций.

Система сборки является **минимальной**, если она выполняет каждую задачу не более одного раза в процессе сборки, при этом задачи выполняются только в том случае, если они прямо или косвенно зависят от входных данных, которые изменились с момента предыдущей сборки.

Важнейшим элементом системы сборки является **граф зависимостей задач**, см. @fig:make1.

![Граф зависимостей задач и два варианта сборки: а) полное перестроение, б) частичное перестроение.](make1.png){#fig:make1}
 
Система сборки включает в себя следующие элементы:

* Хранилище пар ключ-значение. Цель системы сборки привести хранилище в актуальное состояние. Во многих случаях хранилищем является файловая система, где ключами являются имена файлов, а значениями — содержимое файлов. Многие системы сборки используют хеш-суммы от значений для компактного описания данных и быстрой проверки данных на равенство.
* Входные, выходные и промежуточные значения. Входные значения могут предоставляться пользователем или зависеть от выполнения других задач. Выходные значения формируются в результате выполнения задачи. Промежуточные значения формируются в процессе выполнения задачи.
* Постоянная информация о сборке. Эта информация сохраняется от между сборками и представляет собой “память” системы сборки.
* Описание задачи. Пользователь предоставляет описание того, каким образом выходное значение по заданному ключу получается на основе входных зависимостей. 

Система сборки принимает описание задачи, целевой ключ и хранилище и возвращает измененное хранилище, в котором целевой ключ и всего его зависимости принимают актуальные значения.

Постоянная информация о сборке может храниться в одном из следующих вариантов:

* Время модификации файлов в файловой системе. Если время модификации одного из файлов-зависимостей задачи более новое, чем время модификации файла-результата самой задачи — необходимо перестроить задачу.
* Специальный флаг для каждого ключа хранилища, сигнализирующий о том, что данные были обновлены. После сборки все флаги сбрасываются. Когда начинается новая сборка для всех ключей, значения которых изменились после прошлой сборки, устанавливается флаг. Если для ключа и всех его прямых и косвенных зависимостей флаг сброшен, то ключ перестраивать не требуется.
* Граф зависимостей, в котором хранятся хеш-значения файлов-зависимостей.
* Кэш-хранилище с адресацией по хеш-значению файла, а также история всех предыдущих сборок с указанием хеш-значений файлов для каждой задачи. Этот вариант используется для облачного (распределенной) режима работы с системой сборки силами коллектива разработчиков.
  
Системы сборки различаются по типу используемого **алгоритма планировщика**:

* Топологическая сортировка,
* Выполнение с рестартами задач.
* Выполнение с приостановкой задач.

Также системы сборки различаются по типу зависимостей:

* Статические зависимости.
* Динамические зависимости.

**Динамические зависимости** образуются в процессе вычислений и не могут быть определены заранее, до начала выполнения сборки.

На @fig:make2 показан пример динамической зависимости. В файле release.txt находятся все файлы выпуска. Этот файл образуется на основе слияния файлов bins.txt и docs.txt (документация). Файл release.tar является архивом выпуска. Зависимости release.tar не заданы статически. Они определяются содержимым файла release.txt. По этой причине, если информация о файле README добавляется в docs.txt, то необходима поддержка динамических зависимостей для правильной сборки release.tar.

![Пример использования динамической зависимости](make2.png){#fig:make2}

Кроме того, в системе сборка может применяться **техника раннего среза** (early cutoff)  — если задача выполнена, но ее результат не изменился с предыдущей сборки, то нет необходимости исполнять зависимые задачи, то есть процесс сборки можно завершить ранее.

На @fig:make3 показан пример раннего среза. Если в main.c был добавлен новый комментарий, тогда сборка может быть остановлена после определения отсутствия изменений в main.o.

![Пример оптимизации раннего среза](make3.png){#fig:make3}

При использовании облачной системы сборки скорость сборки может быть существенно увеличена, благодаря разделению результатов сборки между участниками команды. При этом облачная сборка может поддержать вариант сборки, при котором локально образуются только конечные результаты сборки, а все промежуточные файлы остаются в облаке.

На @fig:make4 приведен пример сценария работы с облачной системой сборки. Пользователь совершает следующие действия:

* Загружает исходные тексты, их хеш-значения 1, 2 и 3. Затем пользователь запрашивает сборку main.exe. Система сборки определяет с помощью изучения истории предыдущих сборок, что кто-то уже скомпилировал ранее именно эти исходные тексты. Результаты их сборки хранятся в облаке с хешами 4 (util.o) и 5 (main.o). Система сборки далее определяет, что для зависимостями с такими хешами есть main.exe с хешем 6. По ключу 6 из облачного хранилища извлекается конечный результат.
* Далее пользователь изменяет util.c, и его хеш становится равен 7. В облаке комбинации хешей (7, 2) не существует, то есть ранее никто еще не компилировал такой вариант исходного кода. Процесс продолжается до получения нового main.exe, после чего новые варианты файлов и их хеш-значения сохраняются в облаке.

![Пример сценария работы с облачной системой сборки](make4.png){#fig:make4}

## Топологическая сортировка графа зависимостей

**Топологической сортировкой** называют порядок нумерации вершин ориентированного графа, при котором любое ребро идет из вершины с меньшим номером в вершину с большим.
Очевидно, что не любой граф можно отсортировать топологически. Можно доказать, что топологическая сортировка существует для ациклических графов и не существует для циклических.

Пример топологической сортировки показан на @fig:make5.

![Граф и результат его топологической сортировки](make5.png){#fig:make5}

Алгоритм топологической сортировки на основе обхода графа в глубину:

```
// G — исходный граф
function topologicalSort():
    // проверить граф G на ацикличность
    fill(visited,false)
    for v in V(G)
        if not visited[v]
             dfs(v)
    ans.reverse()
 
function dfs(u):
    visited[u]=true
    for (u,v) in E(G)
        if not visited[v]
            dfs(v)
    ans.pushBack(u)
```

## Система сборки make

Утилита make считывает из специального файла с именем Makefile или makefile в текущей директории инструкции о том, как (при помощи каких команд) компилировать и собирать программы, а также информацию, из каких файлов состоит программа, которую надо "сделать".

Одним из главных достоинств make (чрезвычайно полезным при создании больших программ) является то, что он сравнивает времена модификации файлов, и если, к примеру, файл file1.c новее, чем получаемый из него file1.o, то make поймет, что перекомпилировать надо только его, а остальные — не нужно (если они не изменились).

Makefile содержат три основных компонента:

* Правила, как из одних файлов создавать другие (например, .o из .c).
* Так называемые "зависимости", которые указывают, что, например, исполняемый файл proggie собирается из файлов prg_main.o и prg_funcs.o, а те, в свою очередь, получаются из файлов prg_main.c и prg_funcs.c.
* Определения переменных, позволяющие делать Makefile более гибкими.
  
Ниже приведен пример простейшего Makefile:

```makefile 
CC =             gcc
CFLAGS =         -c -W -Wall
 
%.o : %.c
                $(CC) $(CFLAGS) -o $@ $< 
 
all:            program
 
program:        prg_main.o prg_funcs.o
                $(CC) -o proggie prg_main.o prg_funcs.o
```

**Определения переменных**. Строки вида "ИМЯ=значение" -- это определения переменных. Для получения значения переменной используется запись "$(ИМЯ)" (знак доллара, а за ним имя переменной в скобках). Переменная может определяться через значения других переменных, например:

```makefile 
CFLAGS= -c $(WARNINGOPTIONS)
``` 

**Правила**. Запись "%.o : %.c" с последующей командой означает: "для любого файла .c, чтобы из него получить одноименный файл .o, надо выполнить такую-то команду", в данном случае:
 
```makefile 
gcc -c -W -Wall -o $@ $<
```

В правилах всегда используются специальные переменные `$@` и `$<`. Переменная `$@` обозначает "тот файл, который надо получить" (в данном случае .o), а `$<` — "исходный файл" (в данном случае .c). Такие переменные называются автоматическими. В примере:
 
```makefile 
all: library.cpp main.cpp
```
 
* `$@` обозначает all,
* `$<` обозначает library.cpp,
* `$^` обозначает library.cpp main.cpp.

Команда располагается на следующей строке, причем эта строка обязательно должна начинаться с символа табуляции.

Это довольно странное ограничение является основным источником ошибок и запутанности Makefile'ов — ведь визуально отличить символ табуляции от цепочки пробелов невозможно.

**Зависимости**. Запись вида

```makefile 
program: prg_main.o prg_funcs.o
```
 
означает, что файл program зависит от файлов prg_main.o и prg_funcs.o. Файл program называется целью (target), а файлы .o —  зависимостями (dependencies).
В системе make используется планировщик на основе алгоритма топологической сортировки, а постоянная информация о сборке извлекается из времени модификации файлов.

Эволюция систем автоматизации сборки показана на @fig:make6.

![Эволюция систем сборки](make6.png){#fig:make6}
